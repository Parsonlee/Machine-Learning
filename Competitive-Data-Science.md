# PART1

## 数字特征

1. 对于数字特征的缩放和 rank
   - 树形模型不依赖于此类预处理
   - 非树形模型高度需要此类处理
2. 常用的特征处理
   - 标准化。`MaxMinScaler`或者`StandardScaler`
   - 离群值。设置边界，剔除掉离群值，减少对模型决策边界的影响
   - 取对数或平方根。
3. 特征生成  
   依靠创造力和对数据的理解，可以生成更多的数据。例如房价问题上，已知房子总价和面积，可以得到每平米单价等。

## 类别特征与顺序特征

1. 顺序性特征中的数值是以某种有意义的方式进行排序的
2. 标签编码将类别映射为数字
3. 频率编码将类别映射到它们的频率上
4. 标签编码和频率编码经常被用于基于树的的模型
5. 独热编码通常用于非树状模型
6. 类别特征的相互作用可以帮助线性模型和 KNN

## 时间特征和位置特征

1. 日期时间
   - 周期性
   - 行相关或行不相关的事件发生以来的时间
   - 日期之间的差异
2. 坐标
   - 来自训练/测试数据或其他数据的有趣的地方
   - 集群的中心
   - 汇总的统计数据

## 缺失值

1. 填充 NaN 的方法的视情况而定
2. 处理缺失值的通常方法是用-999、平均数或中位数取代它们
3. 缺失的数值可能已经被处理或替换为特殊值
4. 二进制特征 "isnull "可能是有益的
5. 一般来说，避免在特征生成前有 NaN 值
6. XGBoost 可以处理 NaN

# PART2

## EDA

1. 建立数据的直觉
   - 获得领域知识。它有助于更深入地了解问题
   - 检查数据是否是直观的。并与领域知识一致
   - 理解数据是如何产生的。因为这对建立一个适当的验证是至关重要的
   - 常用的函数：`df.info(), df.dtypes, x.value_counts(), x.isnull(), df.describe()`
   - 关于`df.nunique()`和`df.unique()`: 前者在计算时会排除掉 NaN，后者则会将 NaN 视为一个独一无二值
2. 可视化
   探索特征的关系
   - 成对探索：绘制相关性图表：`df.corr() -> plt.matshow()`
   - 成组探索：绘制每列的均值/方差等：`df.mean().plot(style='.')`

## 验证集策略

1. HoldOut
2. KFold
3. LOO (leave-one-out)
4. 对于数据量小的和样本分类不均衡的数据集，采用`stratification`划分数据集，它将使得被划分后的每块中样本类别比例等于原始数据集

## 验证时出现的一些问题

1. 如果我们在验证阶段有很大的分数分散性，我们应该进行广泛的验证
   - 从不同的 Fold 分割中获得平均分数
   - 在一个分割上调整模型，在另一个分割上评估分数
2. 如果提交的分数与本地验证的分数不一致，我们应该
   - 检查我们在公共 LB 中是否有太少的数据
   - 检查我们是否过度拟合
   - 检查我们是否选择了正确的拆分策略
   - 检查训练/测试是否有不同的分布情况
3. 预计 LB 洗牌的原因是：随机性、数据量小、不同的公有/私有分布

# PART3

## 指标

选择竞赛指定的指标来度量模型，并在此基础上进行优化。

## 回归模型指标

- **MSE**, **RMSE**, **R-Squared**
  从优化角度上来说几乎一致
- **MAE**
  更具有鲁棒性，对离群值不那么敏感
- **(R)MSPE**, **MAPE** (percentage)
  加了权重计算的 MSE 和 MAE
- **(R)MSLE**
  对数空间上的 MSE

## 分类模型指标

**Accuracy, Logloss, AUR(ROC), (Quadratic weighted)Kappa**

## 平均数编码

Mean Encoding，正则化，衍生的情况以及优势和劣势。作用于指定的数据集或是特定情况，在此前提下，会产生显著效果
